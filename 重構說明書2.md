前端整合暨 API 服務層重構企劃書 (UI & API Bridge Edition)
一、專案目標
建立一套反應式 (Reactive)、可配置的前端使用者介面與標準化的 API 服務層，以完全發揮新一代預測引擎 (PredictionResult) 的潛力。目標是讓運營人員能透過 UI 介面，直觀地進行策略切換、執行 A/B 測試、並查看詳細的多維度預測報告，最終完全取代舊版預測相關介面與 API。

二、資料物件與 API 協定 (Data Contracts)
API 端點 (Endpoint)

POST /api/v2/predictions (新建)

用途: 執行單次預測，取代舊有 API。

Request Body: { "strategy_tag": "conservative", "symbols": ["BTC", "ETH"] }

Response Body: ActionResponse<PredictionResult[]> (參見下方 DTO)

GET /api/v2/strategies (新建)

用途: 獲取所有可用的預測策略列表，供前端下拉選單使用。

Response Body: ActionResponse<Strategy[]>

資料傳輸物件 (DTO - Data Transfer Objects)

ActionResponse<T> (標準化回應)

用途: 統一所有 API 回應格式。

結構: { "success": boolean, "data": T, "message": string, "code": int }

PredictionResultDTO (前端專用模型)

用途: 作為 PredictionResult Eloquent 模型在 API 的標準輸出。

建議欄位: 包含所有 PredictionResult 的欄位，特別是 predict_rank, predict_score, used_weights, norm_elo 等詳細指標。

StrategyDTO (策略選項)

用途: 填充前端策略選擇器。

結構: { "tag": "conservative", "name": "保守型策略", "description": "採用 70% Elo 和 30% 動量分數" }

三、架構分層設計 (前端與控制器)
API 控制器層 (Controller - Backend)

PredictionController.php (新建或重構)

職責: 處理所有 /api/v2/predictions 和 /api/v2/strategies 的請求。不含業務邏輯，僅作為 HTTP 層與 PredictionService 的橋樑。

方法: executePrediction(Request $request), listStrategies()。

API 客戶端服務層 (API Client - Frontend)

prediction.service.js (新建)

職責: 封裝所有與後端預測 API 的通訊細節。提供清晰、強型別的函數供 Vue 組件調用。

方法: fetchPrediction(strategy, symbols): Promise<PredictionResultDTO[]>、getAvailableStrategies(): Promise<StrategyDTO[]>。

狀態管理層 (State Management - Frontend, e.g., Pinia)

usePredictionStore (新建)

職責: 管理預測流程的共享狀態，包括當前選擇的策略、載入狀態 (loading)、預測結果、錯誤訊息等。

State: currentStrategy, isLoading, results, error

Actions: runPrediction(strategy, symbols), fetchStrategies()

Vue 組件層 (Vue Components - Frontend)

容器組件 (Smart/Container Components)

PredictionDashboard.vue: 整合所有子組件，調用 Pinia store 的 actions，管理整個頁面的業務邏輯。

展示組件 (Dumb/Presentational Components)

StrategySelector.vue: 接收策略列表作為 props，並在使用者選擇後發出事件。

PredictionResultTable.vue: 接收預測結果陣列作為 props，並以表格形式清晰展示。

PredictionScoreChart.vue: 接收預測結果，將 norm_elo, norm_momentum 等分數進行視覺化展示。

四、完整虛擬碼與配置說明
PredictionController.php

PHP

class PredictionController extends Controller {
    public function __construct(private PredictionServiceFactory $factory) {}

    public function executePrediction(Request $request) {
        $validated = $request->validate([
            'strategy_tag' => 'required|string',
            'symbols' => 'required|array',
        ]);

        try {
            $service = $this->factory->create($validated['strategy_tag']);
            $results = $service->predict($validated['symbols'], time()); // 假設 history 從服務內部獲取
            return response()->json(['success' => true, 'data' => $results]);
        } catch (\Exception $e) {
            return response()->json(['success' => false, 'message' => $e->getMessage()], 500);
        }
    }

    public function listStrategies() {
        $strategies = config('prediction.strategies'); // 從配置文件讀取
        // 格式化為 StrategyDTO
        return response()->json(['success' => true, 'data' => $formattedStrategies]);
    }
}
prediction.service.js

JavaScript

import axios from 'axios';

const apiClient = axios.create({ baseURL: '/api/v2' });

export const predictionService = {
    async fetchPrediction(strategyTag, symbols) {
        const response = await apiClient.post('/predictions', {
            strategy_tag: strategyTag,
            symbols: symbols,
        });
        if (response.data.success) {
            return response.data.data; // Returns PredictionResultDTO[]
        }
        throw new Error(response.data.message);
    },

    async getAvailableStrategies() {
        // ...
    }
};
usePredictionStore.js (Pinia Store)

JavaScript

import { defineStore } from 'pinia';
import { predictionService } from '@/services/prediction.service.js';

export const usePredictionStore = defineStore('prediction', {
    state: () => ({
        isLoading: false,
        results: [],
        error: null,
    }),
    actions: {
        async runPrediction(strategyTag, symbols) {
            this.isLoading = true;
            this.error = null;
            try {
                this.results = await predictionService.fetchPrediction(strategyTag, symbols);
            } catch (e) {
                this.error = e.message;
            } finally {
                this.isLoading = false;
            }
        },
    },
});
PredictionDashboard.vue

Code snippet

<template>
    <div>
        <StrategySelector @select="handleStrategySelect" :strategies="strategies" />
        <button @click="run" :disabled="store.isLoading">
            {{ store.isLoading ? '預測中...' : '執行預測' }}
        </button>
        <div v-if="store.error">{{ store.error }}</div>
        <PredictionResultTable :results="store.results" />
    </div>
</template>

<script setup>
import { usePredictionStore } from '@/stores/usePredictionStore';
// ... import components and services

const store = usePredictionStore();
// ... onMounted: fetch strategies
// ... methods: handleStrategySelect, run
</script>
五、資料流與使用範例
使用者執行一次預測的完整流程：

使用者進入頁面: PredictionDashboard.vue 觸發 fetchStrategies action，從後端 /api/v2/strategies 獲取策略列表並渲染 StrategySelector.vue。

使用者選擇策略: 使用者從下拉選單中選擇 "Aggressive"（進攻型）策略。

執行預測: 使用者點擊「執行預測」按鈕。

Vue 組件: 按鈕的點擊事件觸發 store.runPrediction('aggressive', ['BTC', 'ETH']) action。

Pinia Store: isLoading 設為 true，並調用 predictionService.fetchPrediction(...)。

API 服務層: prediction.service.js 發送 POST 請求到 /api/v2/predictions。

Laravel 後端:

PredictionController 接收請求。

通過 PredictionServiceFactory 創建一個配置了 "Aggressive" 策略的 PredictionService 實例。

PredictionService 執行完整的計算、儲存 PredictionResult 記錄。

PredictionController 將新生成的 PredictionResult 記錄作為 JSON 回應。

前端接收:

predictionService 收到成功回應。

Pinia store 的 results 狀態被更新為 API 回傳的數據，isLoading 設為 false。

UI 重新渲染: Vue 的響應式系統自動偵測到 store.results 的變化，PredictionResultTable.vue 和 PredictionScoreChart.vue 等子組件立即顯示最新的預測結果。

六、進階優化與未來擴展
即時結果更新: 整合 WebSocket，當後端 PredictionService 完成計算時，主動推送結果到前端，無需使用者手動刷新。

A/B 測試面板: 建立一個專門的 UI 介面，允許運營人員選擇兩種或多種策略（如 'conservative' vs 'aggressive'），並排比較它們對同一組遊戲回合的預測結果。

歷史回測 UI: 建立一個 UI，讓使用者可以選擇歷史時間範圍和策略參數，觸發後端的 BacktestService，並在前端以報告和圖表的形式展示回測結果（勝率、夏普比率等）。

前端快取: 對不常變動的數據（如策略列表）進行客戶端快取，減少 API 請求。

七、專案交付規範
棄用舊 API: 舊的預測相關 API 端點（如 /api/auto-betting/predict）應標記為 deprecated，並在所有前端調用都遷移後，制定移除計畫。

組件化與代碼風格: 所有 Vue 組件必須遵循模組化、單一職責原則。專案需有統一的 ESLint 和 Prettier 配置以確保代碼風格一致。

端到端測試 (E2E Test): 至少為「選擇策略 -> 執行預測 -> 顯示結果」這一核心流程編寫一套端到端測試（例如使用 Cypress 或 Playwright）。
