# 历史与分析模块技术实现文档

## 概述

历史与分析模块是自动下注系统的核心数据分析组件，包含三个主要功能区块：

1**🔮 预测统计分析** - AI预测模型的性能分析2. **⚡ 动能预测统计分析** - Hybrid-Edge动能预测算法分析  
3. **📊 投注表现分析** - 用户实际下注结果分析

## 1. 🔮 预测统计分析

###10.1 数据流程

#### 前端数据获取

```typescript
// 数据来源：gamePredictionStore
const predictionHistory = ref<PredictionHistoryRound[]>([]);
const predictionStats = usePredictionStats(predictionHistory, recentRoundsCount);

// API调用
const fetchPredictionHistory = async () => [object Object]  const response = await api.get('/game/prediction-history');
  predictionHistory.value = response.data.data;
};
```

#### 后端数据提供

```php
// GameDataController::getPredictionHistory()
public function getPredictionHistory(): JsonResponse
[object Object]    // 获取最近300局的预测数据
    $rounds = GameRound::with([roundPredicts',roundResults'])
        ->whereHas('roundPredicts)
        ->orderBy('created_at,desc)
        ->limit(300)
        ->get()
        ->map(function ($round)[object Object]
            // 构建预测数据
            $predictions = $round->roundPredicts->sortBy(predicted_rank)                ->map(function ($predict) {
                    return [
                   symbol' => $predict->token_symbol,
                      predicted_rank' => $predict->predicted_rank,
                        prediction_score' => $predict->prediction_score,
                       predicted_at' => $predict->predicted_at?->format('Y-m-d H:i:s'),
                    ];
                })->values()->toArray();

            // 构建实际结果数据
            $results = $round->roundResults->sortBy('rank)                ->map(function ($result) {
                    return [
                   symbol' => $result->token_symbol,
                        actual_rank=> $result->rank,
                        value' => $result->value,
                    ];
                })->values()->toArray();

            return
             round_id => $round->round_id,
               settled_at' => $round->settled_at?->format('Y-m-d H:i:s'),
                predictions' => $predictions,
            results' => $results,
            ];
        });

    return response()->json(
       success=> true,
       data' => $rounds,
    ]);
}
```

###10.2 统计计算逻辑

#### 精准预测率计算

```typescript
// usePredictionStats.ts
const calculateRoundBasedStats = computed(() => {
    let exactPredictions = 0;
    let totalPredictions = 0 predictionHistory.value.forEach((round) => {
        const top3Predictions = round.predictions.filter((p) => p.predicted_rank <= 3);

        top3Predictions.forEach((prediction) => {
            const actualResult = round.results.find((r) => r.symbol === prediction.symbol);
            if (actualResult)[object Object]             totalPredictions++;
                if (prediction.predicted_rank === actualResult.actual_rank) {
                    exactPredictions++;
                }
            }
        });
    });

    return {
        exactRate: totalPredictions >0 (exactPredictions / totalPredictions) * 100  };
});
```

#### 排名统计计算

```typescript
// 按预测排名分别统计保本/亏本率和第一名率
const calculateRankBasedStats = computed((): AllRankStats => {
    const rankStats = [object Object]    rank1{ total: 0, breakeven:0oss:0firstPlace: 0, breakevenRate: 0, lossRate: 0, firstPlaceRate: 0 },
        rank2{ total: 0, breakeven:0oss:0firstPlace: 0, breakevenRate: 0, lossRate: 0, firstPlaceRate: 0 },
        rank3{ total: 0, breakeven:0oss:0firstPlace: 0, breakevenRate: 0, lossRate: 0, firstPlaceRate: 0 }
    };

    predictionHistory.value.forEach((round) => [object Object]       1, 3].forEach((predictedRank) => {
            const predictions = round.predictions.filter((p) => p.predicted_rank === predictedRank);

            predictions.forEach((prediction) =>[object Object]             const actualResult = round.results.find((r) => r.symbol === prediction.symbol);
                if (actualResult) {
                    const key = `rank${predictedRank}` as keyof AllRankStats;
                    rankStats[key].total++;

                    // 保本：实际排名 <= 3
                    if (actualResult.actual_rank <= 3) {
                        rankStats[key].breakeven++;
                    } else {
                        rankStats[key].loss++;
                    }

                    // 第一名：实际排名 = 1
                    if (actualResult.actual_rank === 1) {
                        rankStats[key].firstPlace++;
                    }
                }
            });
        });
    });

    // 计算百分比
    Object.keys(rankStats).forEach((key) => {
        const stats = rankStats[key as keyof AllRankStats];
        if (stats.total > 0) {
            stats.breakevenRate = (stats.breakeven / stats.total) * 100;
            stats.lossRate = (stats.loss / stats.total) * 100;
            stats.firstPlaceRate = (stats.firstPlace / stats.total) * 100       }
    });

    return rankStats;
});
```

###13 数据存储结构

#### 数据库表结构

```sql
-- 游戏轮次表
CREATE TABLE game_rounds (
    id BIGINT PRIMARY KEY,
    round_id VARCHAR(255) UNIQUE,
    settled_at TIMESTAMP NULL,
    created_at TIMESTAMP
);

-- 预测记录表
CREATE TABLE round_predicts (
    id BIGINT PRIMARY KEY,
    game_round_id BIGINT,
    token_symbol VARCHAR(50    predicted_rank INT,
    prediction_score DECIMAL(10,2),
    predicted_at TIMESTAMP,
    FOREIGN KEY (game_round_id) REFERENCES game_rounds(id)
);

-- 实际结果表
CREATE TABLE round_results (
    id BIGINT PRIMARY KEY,
    game_round_id BIGINT,
    token_symbol VARCHAR(50
    rank INT,
    value DECIMAL(20),
    FOREIGN KEY (game_round_id) REFERENCES game_rounds(id)
);
```

## 2. ⚡ 动能预测统计分析

###20.1 数据流程

#### 前端数据获取

```typescript
// 动能预测历史数据
const momentumPredictionHistory = ref<MomentumPredictionHistoryRound[]>([]);
const momentumStats = useMomentumPredictionStats(momentumPredictionHistory, momentumRecentRoundsCount);

// API调用
const fetchMomentumHistory = async () => {
    const response = await gameApi.getMomentumPredictionHistory();
    momentumPredictionHistory.value = response.data.data ||];
};
```

#### 后端数据提供

```php
// GameDataController::getMomentumPredictionHistory()
public function getMomentumPredictionHistory(): JsonResponse[object Object]
    // 获取所有已结算的回合，预加载关联数据
    $rounds = GameRound::with(['hybridRoundPredicts',roundResults'])
        ->whereHas('hybridRoundPredicts)    ->whereNotNull('settled_at)
        ->orderBy('settled_at,desc)
        ->limit(300        ->get();

    $historyData =    foreach ($rounds as $round)[object Object]
        // 构建动能预测数据
        $predictions = $round->hybridRoundPredicts
            ->sortBy(predicted_rank')
            ->map(function ($prediction)[object Object]            return [
                   symbol =>$prediction->token_symbol,
                  predicted_rank => $prediction->predicted_rank,
                  momentum_score => $prediction->mom_score,
                   confidence => $prediction->confidence
                ];
            })
            ->values()
            ->toArray();

        // 构建实际结果数据
        $results = $round->roundResults
            ->sortBy('rank')
            ->map(function ($result)[object Object]            return [
               symbol' => $result->token_symbol,
                    actual_rank => $result->rank
                ];
            })
            ->values()
            ->toArray();

        $historyData = [
         round_id => $round->round_id,
           settled_at' => $round->settled_at?->toISOString(),
            predictions' => $predictions,
        results' => $results
        ];
    }

    return response()->json(
       success=> true,
        data => $historyData
    ]);
}
```

###20.2 统计计算逻辑

#### 动能预测准确率计算

```typescript
// useMomentumPredictionStats.ts
const calculateMomentumAccuracy = computed(() => {
    let exactPredictions = 0;
    let totalPredictions = 0;

    momentumPredictionHistory.value.forEach((round) => {
        const top3Predictions = round.predictions.filter((p) => p.predicted_rank <= 3);

        top3Predictions.forEach((prediction) => {
            const actualResult = round.results.find((r) => r.symbol === prediction.symbol);
            if (actualResult)[object Object]             totalPredictions++;
                if (prediction.predicted_rank === actualResult.actual_rank) {
                    exactPredictions++;
                }
            }
        });
    });

    return totalPredictions >0 (exactPredictions / totalPredictions) * 100:0;
});
```

#### 平均动能分数计算

```typescript
const calculateAverageMomentumScore = computed(() => {
  let totalScore = 0;
  let totalPredictions = 0;

  momentumPredictionHistory.value.forEach((round) => {
    const top3Predictions = round.predictions.filter((p) => p.predicted_rank <= 3);
    top3Predictions.forEach((prediction) => {
      totalScore += prediction.momentum_score;
      totalPredictions++;
    });
  });

  return totalPredictions > 0 ? totalScore / totalPredictions : 0;
});
```

###23 数据存储结构

#### 数据库表结构

```sql
-- Hybrid动能预测表
CREATE TABLE hybrid_round_predicts (
    id BIGINT PRIMARY KEY,
    game_round_id BIGINT,
    token_symbol VARCHAR(50    predicted_rank INT,
    mom_score DECIMAL(10,4),      -- 动能分数
    confidence DECIMAL(104  -- 置信度
    final_score DECIMAL(104    -- 最终分数
    elo_prob DECIMAL(104),       -- Elo概率
    FOREIGN KEY (game_round_id) REFERENCES game_rounds(id)
);
```

## 3. 📊 投注表现分析

###30.1 数据流程

#### 前端数据获取

```typescript
// 投注表现分析组件
const refreshAnalysis = async () => {
  const apiOptions = {
    filterType: filterType.value,
    ...(filterType.value === 'days' ? { days: selectedDays.value } : { limitRounds: selectedRounds.value })
  };

  const response = await bettingAnalysisApi.getPerformanceAnalysis(props.uid, apiOptions);

  if (response.data.success) {
    const data = response.data.data;
    backendStats.value = data.betting_performance || {};
    bettingRecords.value = (data.detailed_records || []).map((record: any) => ({
      id: record.id,
      created_at: record.created_at,
      round_id: record.round_id,
      token_symbol: record.token_symbol,
      predicted_rank: record.predicted_rank,
      actual_rank: record.actual_rank,
      success: record.success,
      bet_amount: record.bet_amount,
      is_top3: record.actual_rank ? record.actual_rank <= 3 : null
    }));
  }
};
```

#### 后端数据提供

```php
// PredictionAnalysisController::getUserBettingPerformance()
public function getUserBettingPerformance(Request $request): JsonResponse
{
    $uid = $request->input('uid');
    $filterType = $request->input('filter_type', days');
    $days = $request->input('days');
    $limitRounds = $request->input(limit_rounds);

    // 获取用户的下注记录（包含实际结果）
    $bettingAnalysis = $this->calculateBettingPerformance($uid, $days, $limit, $limitRounds);

    // 获取预测准确度分析
    $predictionAnalysis = $this->calculatePredictionAccuracy($uid, $days, $limitRounds);

    // 获取策略表现分析
    $strategyAnalysis = $this->calculateStrategyPerformance($uid, $days, $limitRounds);

    // 获取详细的投注记录
    $detailedRecords = $this->getDetailedBettingRecords($uid, $limit, $limitRounds);

    return response()->json(
       success=> true,
  data=>     betting_performance' => $bettingAnalysis,
      prediction_accuracy' => $predictionAnalysis,
            strategy_analysis' => $strategyAnalysis,
            detailed_records' => $detailedRecords,
        ]
    ]);
}
```

### 30.2 统计计算逻辑

#### 投注表现计算

```php
private function calculateBettingPerformance(string $uid, ?int $days, int $limit, ?int $limitRounds = null): array
[object Object]    // 获取下注记录的基础查询
    $query = AutoBettingRecord::where('uid', $uid)
        ->with(['gameRound.roundResults'])
        ->orderBy('created_at',desc);

    // 根据筛选类型应用不同的条件
    if ($limitRounds !== null) [object Object]
        // 按局数筛选：获取最新的N局记录
        $query->limit($limitRounds);
    } else if ($days !== null) [object Object]
        // 按天数筛选：-1全部历史
        if ($days > 0            $query->where('created_at', '>=', now()->subDays($days));
        }
        $query->limit($limit);
    }

    $records = $query->get();

    $totalBets = $records->count();
    $totalAmount = $records->sum(bet_amount');
    $successfulBets = $records->where(success', true)->count();

    // 计算实际盈亏
    $actualProfitLoss = 0;
    $winningBets = 0
    $losingBets = 0    $breakEvenBets = 0;
    $settledBets = 0 foreach ($records as $record) {
        if (!$record->success) continue;

        // 查找该下注对应的实际游戏结果
        $gameRound = GameRound::where('round_id', $record->round_id)->first();
        if (!$gameRound) continue;

        $actualResult = RoundResult::where(game_round_id', $gameRound->id)
            ->where('token_symbol', strtoupper($record->token_symbol))
            ->first();

        if (!$actualResult) continue;

        $settledBets++;
        $actualRank = $actualResult->rank;
        $betAmount = (float) $record->bet_amount;

        // 计算实际收益
        $payout = $this->calculatePayout($actualRank, $betAmount);
        $profit = $payout - $betAmount;
        $actualProfitLoss += $profit;

        // 业务逻辑：以排名为主要成功标准，只有前三名才算盈利
        if ($actualRank === 1[object Object]          $winningBets++;
        } elseif ($actualRank <= 3            $breakEvenBets++;
        } else {
            $losingBets++;
        }
    }

    return       total_bets' => $totalBets,
       successful_bets' => $successfulBets,
       settled_bets' => $settledBets,
       total_amount' => $totalAmount,
    actual_profit_loss => $actualProfitLoss,
   win_rate_percentage' => $settledBets > 0? (($winningBets + $breakEvenBets) / $settledBets) * 100 : 0,
   betting_distribution=>          winning_bets' => $winningBets,
           break_even_bets' => $breakEvenBets,
            losing_bets' => $losingBets
        ]
    ];
}
```

###33 数据存储结构

#### 数据库表结构

```sql
-- 自动下注记录表
CREATE TABLE auto_betting_records (
    id BIGINT PRIMARY KEY,
    uid VARCHAR(255),                    -- 用户ID
    round_id VARCHAR(255,               -- 轮次ID
    token_symbol VARCHAR(50),            -- 代币符号
    bet_amount DECIMAL(10,2),            -- 下注金额
    bet_id VARCHAR(255),                 -- 下注ID
    success BOOLEAN,                     -- 下注是否成功
    prediction_data JSON,                -- 预测数据
    result_data JSON,                    -- 结果数据
    profit_loss DECIMAL(10,2),           -- 盈亏
    status VARCHAR(50),                  -- 状态
    created_at TIMESTAMP,
    updated_at TIMESTAMP
);
```

## 4据同步机制

###40.1WebSocket实时更新

```typescript
// gamePredictionStore.ts
const initializeWebSocket = () => [object Object]   // 监听预测数据更新
    predictionsChannel = window.Echo.channel('predictions)
        .listen(PredictionUpdated,(event: any) => {
            console.log('🔮 收到预测数据更新:', event);
            // 更新当前分析数据
            if (event.data && Array.isArray(event.data))[object Object]           currentAnalysis.value = event.data;
                analysisMeta.value = event.meta || null;
            }
        });

    // 监听Hybrid预测数据更新
    hybridPredictionsChannel = window.Echo.channel('hybrid-predictions)
        .listen('HybridPredictionUpdated,(event: any) => {
            console.log('⚡ 收到Hybrid预测数据更新:', event);
            // 更新Hybrid预测数据
            if (event.data && Array.isArray(event.data))[object Object]            hybridPredictions.value = event.data;
                hybridAnalysisMeta.value = event.meta || null;
            }
        });
};
```

###4.2缓存策略

```php
// 预测数据缓存
Cache::put(game:current_prediction, $cacheData, now()->addMinutes(30));

// Hybrid预测数据缓存
Cache::put(hybrid_prediction:{$roundId}", $hybridPredictions, now()->addMinutes(5));

// 用户状态缓存
Cache::put("auto_betting_status_{$uid}", $status, now()->addHours(1);
```

##5 性能优化

### 5.1数据库查询优化

```php
// 使用预加载减少N+1rounds = GameRound::with([roundPredicts',roundResults])
    ->whereHas('roundPredicts)->orderBy('created_at', 'desc)
    ->limit(30)
    ->get();

// 使用索引优化查询
CREATE INDEX idx_auto_betting_records_uid_created ON auto_betting_records(uid, created_at);
CREATE INDEX idx_round_predicts_game_round_id ON round_predicts(game_round_id);
CREATE INDEX idx_hybrid_round_predicts_game_round_id ON hybrid_round_predicts(game_round_id);
```

### 5.2能优化

```typescript
// 使用计算属性缓存计算结果
const calculateRankBasedStats = computed(() =>[object Object]
    // 复杂的统计计算，结果会被缓存
    return rankStats;
});

// 使用防抖优化频繁更新
const debouncedRefresh = debounce(() => {
    refreshAnalysis();
},30);
```

##6. 错误处理

### 6.1误处理

```typescript
const refreshAnalysis = async () => {
    try {
        const response = await bettingAnalysisApi.getPerformanceAnalysis(props.uid, apiOptions);
        // 处理成功响应
    } catch (error)[object Object]     console.error('📊 API请求失败:, error);
        handleError(error, [object Object]         showToast: true,
            fallbackMessage: 获取投注记录失败'
        });
    } finally[object Object]     loading.value = false;
    }
};
```

### 60.2后端错误处理

```php
try {
    $bettingAnalysis = $this->calculateBettingPerformance($uid, $days, $limit, $limitRounds);
    // 处理成功结果
} catch (\Exception $e) [object Object]    Log::error(获取用户投注表现分析失败,        uid> $uid ?? unknown,        error => $e->getMessage(),
        trace' => $e->getTraceAsString()
    ]);

    return response()->json(
        success' => false,
        message' => 获取投注表现分析失败:  . $e->getMessage()
    ], 50);
}
```

## 7 总结

历史与分析模块通过以下技术架构实现：1 **数据层**：使用Laravel Eloquent ORM管理数据库关系2. **服务层**：通过Service类封装业务逻辑
3 **控制器层**：处理HTTP请求和响应
4用Vue 3omposition API和Pinia状态管理5**实时通信**：通过Laravel Echo WebSocket实现实时数据更新6. **缓存策略**：使用Redis缓存热点数据
7 **错误处理**：前后端统一的错误处理机制

该模块为自动下注系统提供了全面的数据分析能力，帮助用户了解AI预测模型的性能和实际下注表现，为策略优化提供数据支撑。
