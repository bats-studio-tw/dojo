第三階段重構企劃書：智能化營運與決策支援系統 (Reverb 精準版)
一、 專案目標

在現有的 V2 預測引擎和 API 基礎上，打造一個集自動化回測、A/B 測試、即時監控與視覺化分析於一體的智能化營運平台。目標是賦予營運團隊獨立完成策略評估、上線、監控與優化全流程的能力，並為未來的機器學習自動調參鋪平道路。

二、 核心功能模組

1. 歷史回測與分析中心 (Backtest & Analytics Center)

此模組旨在完善已有的 BacktestService 並為其建立一個功能完善的前端操作介面。

後端 (BacktestService 完善):

任務 1 (實現專業回測指標): 在 runBacktest 方法中，完整計算以下關鍵績效指標(KPIs)：勝率 (Win Rate)、保本率 (Breakeven Rate)、夏普比率 (Sharpe Ratio)、最大回撤 (Max Drawdown)、單次最大盈虧、平均盈虧比。

任務 2 (實現參數矩陣批測 - Grid Search): 完善 gridSearch 方法，使其能根據傳入的參數矩陣（例如不同的 weights 和 normalization 組合）自動執行多次回測，並將每次的結果與參數快照一同存入 PredictionResult 表或一個新的 BacktestReport 表中，以便進行比較分析。

任務 3 (非同步任務處理): 將耗時較長的回測任務（runBacktest 和 gridSearch）整合至 Laravel Queue。這能防止 HTTP 請求逾時，並在任務完成後透過事件通知前端，提升使用者體驗。

前端 (新建 BacktestDashboard.vue):

任務 1 (回測配置介面): 提供一個直觀的 UI，允許使用者自由選擇歷史時間範圍、選擇既有策略 (strategy_tag)、甚至能動態輸入一組參數矩陣以執行 Grid Search。

任務 2 (非同步任務監控): 提交回測任務後，前端介面應能顯示「處理中」狀態，並透過輪詢或 WebSocket（推薦）監聽後端任務進度及完成信號。

任務 3 (回測報告視覺化): 收到回測結果後，以表格和圖表（例如使用 Chart.js 或 ECharts）清晰展示各項回測指標。對於 Grid Search 結果，應提供互動式排序功能，讓營運人員能一目了然地找出最優的參數組合。

虛擬碼實作細節 (app/Services/Prediction/BacktestService.php):

PHP

<?php

namespace App\Services\Prediction;

use App\Jobs\RunBacktestJob; // 將要建立的 Job
use Illuminate\Support\Facades\Bus; // 用於鏈式任務

class BacktestService
{
    public function __construct(private PredictionService $service) {}

    /**
     * 主入口：接收配置並將其分派到隊列中執行
     * @return string Job Batch ID，用於前端查詢進度
     */
    public function startBacktest(array $rounds, array $strategyConfig, ?int $userId = null): string
    {
        $batch = Bus::batch([
            new RunBacktestJob($rounds, $strategyConfig, $userId),
        ])->then(function ($batch) {
            // 所有任務成功完成後的回調
            // 例如：透過 WebSocket 通知使用者 backtest.completed
        })->name("Backtest for strategy: " . $strategyConfig['strategy_tag'])
          ->dispatch();

        return $batch->id;
    }

    /**
     * Grid Search 的入口
     */
    public function startGridSearch(array $rounds, array $paramMatrix, ?int $userId = null): string
    {
        $jobs = [];
        // 解析參數矩陣，產生所有可能的策略組合
        foreach ($paramMatrix['weights'] as $weights) {
            foreach ($paramMatrix['normalization'] as $normalization) {
                $strategyConfig = [
                    'strategy_tag' => 'grid_search_' . uniqid(),
                    'weights' => $weights,
                    'normalization' => $normalization,
                ];
                $jobs[] = new RunBacktestJob($rounds, $strategyConfig, $userId);
            }
        }

        $batch = Bus::batch($jobs)
                    ->name("Grid Search Backtest")
                    ->dispatch();

        return $batch->id;
    }
}
虛擬碼實作細節 (app/Jobs/RunBacktestJob.php):

PHP

<?php

namespace App\Jobs;

use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;
use App\Services\Prediction\PredictionService;
use App\Models\BacktestReport; // 儲存回測結果的模型

class RunBacktestJob implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    public function __construct(
        private array $rounds,
        private array $strategyConfig,
        private ?int $userId
    ) {}

    public function handle(PredictionService $predictionService): void
    {
        $results = [];
        foreach ($this->rounds as $round) {
            // 1. 使用 PredictionService 針對每一回合進行預測
            $prediction = $predictionService->predictForBacktest($round->symbols, $round->timestamp, $this->strategyConfig);
            // 2. 比較預測結果與實際賽果，收集數據
            // $results[] = ...
        }

        // 3. 根據收集到的 $results 計算所有指標
        $winRate = $this->calculateWinRate($results);
        $sharpeRatio = $this->calculateSharpeRatio($results);
        // ... etc

        // 4. 將最終報告儲存到資料庫
        BacktestReport::create([
            'user_id' => $this->userId,
            'strategy_config' => $this->strategyConfig,
            'win_rate' => $winRate,
            'sharpe_ratio' => $sharpeRatio,
        ]);
    }

    private function calculateWinRate(array $results): float { /* ... */ }
    private function calculateSharpeRatio(array $results): float { /* ... */ }
}
2. A/B 測試管理面板 (A/B Testing Panel)

此模組讓營運人員可以在真實環境中，科學地比較不同預測策略的表現。

後端 (擴展 PredictionService & Controller):

任務 1 (流量分配邏輯): 在 PredictionService 或其上層引入流量分配機制。例如，可以設定一個請求中，50% 的流量使用 conservative 策略，50% 使用 aggressive 策略，並將使用的策略標籤記錄在 PredictionResult 中。

任務 2 (A/B 測試專用 API): 新增 API 端點，如 POST /api/v2/ab-test/start 用於啟動一項 A/B 測試設定，以及 GET /api/v2/ab-test/report 用於獲取指定時間範圍內不同策略的表現對比報告。

前端 (新建 ABTestingDashboard.vue):

任務 1 (測試配置介面): 建立一個 UI，讓使用者可以選擇兩種或多種策略進行對比，設定測試的起止時間和流量分配比例。

任務 2 (即時表現報告): 調用報告 API，以並排比較或圖表疊加的方式，視覺化展示不同策略在真實環境下的即時表現（如勝率、預測分數分佈、盈虧曲線等）。

3. 即時預測儀表板 (Real-time Prediction Dashboard) - (啟用 Laravel Reverb 即時推送)

此模組旨在升級現有的預測儀表板，從手動刷新升級為零延遲的即時數據流。

後端 (整合 Laravel Broadcasting 至 Reverb):

任務 1 (建立廣播事件): 執行 php artisan make:event NewPredictionMade 並確保該事件 implements ShouldBroadcast。在事件中定義一個公開的廣播頻道，例如 new Channel('predictions')。

任務 2 (觸發事件): 在 PredictionService 中，每當一筆新的 PredictionResult 記錄成功寫入資料庫後，立即廣播此事件：NewPredictionMade::dispatch($newPredictionRecord);。

任務 3 (確保 Reverb 運行): 在部署和開發流程中，確保 php artisan reverb:start 指令已被整合，以保持 Reverb 伺服器持續運行。同時，確認 .env 檔案中的 BROADCAST_DRIVER 和 REVERB_* 相關變數均已正確配置。

前端 (監聽 Reverb 推送):

任務 1 (監聽頻道事件): 在 PredictionDashboard.vue 組件的 onMounted 生命週期鉤子中，使用專案中已配置好的 window.Echo 實例，連接到 Reverb 伺服器並監聽 predictions 頻道的 NewPredictionMade 事件。

任務 2 (即時更新 UI): 在 Pinia Store (prediction.ts) 中新增一個 Action (例如 addRealtimePrediction)。當監聽到事件後，調用此 Action 將收到的新預測數據以高效的方式插入到 results 狀態陣列的頂部。Vue 的響應式系統將自動、即時地更新結果表格與圖表，無需任何手動操作。

任務 3 (清理監聽器): 在組件的 onUnmounted 鉤子中，調用 window.Echo.leaveChannel('predictions') 來停止監聽，以避免內存洩漏和不必要的連線。

虛擬碼實作細節 (app/Services/Prediction/PredictionService.php):

PHP

<?php

namespace App\Services\Prediction;

use App\Events\NewPredictionMade; // 引入要廣播的事件
use App\Models\PredictionResult;

class PredictionService
{
    // ... (constructor)

    public function predict(array $symbols, int $timestamp, array $history): array
    {
        // ... (原有的行情獲取、特徵計算、分數混合等邏輯不變)
        // $finalScores = ...

        $predictionsToReturn = [];

        foreach ($finalScores as $symbol => $scoreDetails) {
            // 1. 將預測結果寫入資料庫
            $predictionRecord = PredictionResult::create([ /* ...所有欄位... */ ]);

            // 2. 觸發 (dispatch) 事件，將新建立的 Eloquent 模型傳遞過去
            NewPredictionMade::dispatch($predictionRecord);

            $predictionsToReturn[] = $predictionRecord->toArray();
        }

        return $predictionsToReturn;
    }
}
虛擬碼實作細節 (resources/js/stores/prediction.ts):

TypeScript

import { defineStore } from 'pinia';
import { predictionService } from '@/services/prediction.service';
import type { PredictionResultDTO } from '@/types';

export const usePredictionStore = defineStore('prediction', {
    state: () => ({
        isLoading: false,
        results: [] as PredictionResultDTO[],
        error: null as string | null,
    }),
    actions: {
        async runPrediction(strategyTag: string, symbols: string[]) {
            // ... (保留原有手動觸發邏輯)
        },

        /**
         * 新增的 Action，用於處理 WebSocket 推送的數據
         */
        addRealtimePrediction(newPrediction: PredictionResultDTO) {
            const exists = this.results.some(p => p.id === newPrediction.id);
            if (!exists) {
                this.results.unshift(newPrediction);
                if (this.results.length > 100) {
                    this.results.pop();
                }
            }
        },
    },
});
虛擬碼實作細節 (resources/js/components/PredictionDashboard.vue):

Code snippet

<template>
    <div>
        <div class="realtime-indicator">
            <span :class="{'connected': isConnected}"></span>
            {{ isConnected ? '即時監聽中' : '未連接' }}
        </div>
        <PredictionResultTable :results="store.results" />
    </div>
</template>

<script setup lang="ts">
import { ref, onMounted, onUnmounted } from 'vue';
import { usePredictionStore } from '@/stores/usePredictionStore';
// ...

const store = usePredictionStore();
const isConnected = ref(false);

onMounted(() => {
    // @ts-ignore
    if (window.Echo) {
        // @ts-ignore
        window.Echo.channel('predictions')
            .listen('.NewPredictionMade', (event: { prediction: PredictionResultDTO }) => {
                store.addRealtimePrediction(event.prediction);
            });

        // @ts-ignore
        window.Echo.connector.pusher.connection.bind('connected', () => { isConnected.value = true; });
        // @ts-ignore
        window.Echo.connector.pusher.connection.bind('disconnected', () => { isConnected.value = false; });
        // @ts-ignore
        isConnected.value = window.Echo.connector.pusher.connection.state === 'connected';
    }
});

onUnmounted(() => {
    // @ts-ignore
    if (window.Echo) {
        // @ts-ignore
        window.Echo.leaveChannel('predictions');
    }
});
</script>

<style scoped>
.realtime-indicator span {
    display: inline-block; width: 10px; height: 10px;
    border-radius: 50%; background-color: #f00;
}
.realtime-indicator span.connected { background-color: #0f0; }
</style>
四、 技術棧與架構建議

非同步任務: Laravel Queue + Redis (推薦，效能更佳)

即時通訊: Laravel Reverb (專案現有)，由後端 Laravel Broadcasting 和前端 pusher-js 客戶端驅動。

前端圖表: Chart.js 或 ECharts (根據視覺化需求的複雜度選擇)

資料庫: 建議為回測報告建立新表 backtest_reports，記錄每次回測的總體結果與所用參數，與單筆預測記錄的 prediction_results 表分離，使職責更清晰。

五、 專案交付藍圖 (Roadmap)

建議將此企劃書拆分為多個衝刺 (Sprint) 進行交付：

Sprint 1 (後端基石):

重點: 完成 BacktestService 的核心指標計算和 Grid Search 邏輯。

交付: 將回測任務整合進 Laravel Queue；建立 backtest_reports 資料表遷移檔案。

Sprint 2 (回測中心 UI):

重點: 讓營運人員可以使用回測功能。

交付: 開發 BacktestDashboard.vue，實現回測配置、非同步任務提交與報告視覺化，完成前後端完整對接。

Sprint 3 (即時儀表板升級):

重點: 提升即時監控體驗。

交付: 在後端實作 NewPredictionMade 事件的廣播；改造 PredictionDashboard.vue 以接收並展示來自 Reverb 的即時數據。

Sprint 4 (A/B 測試上線):

重點: 賦予策略實驗的能力。

交付: 設計並實作後端的 A/B 測試流量分配與報告 API；開發 ABTestingDashboard.vue 前端介面。
